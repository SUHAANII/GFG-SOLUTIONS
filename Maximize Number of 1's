question: Given a binary array arr[] containing only 0s and 1s and an integer k, you are allowed to flip at most k 0s to 1s. Find the maximum number of consecutive 1's that can be obtained in the array after performing the operation at most k times.



code:

class Solution {
  public:
    int maxOnes(vector<int>& arr, int k) {
        // Initialize variables
        int maxi = 0;         // To keep track of the maximum length of subarray found
        int zeroCount = 0;    // To count the number of zeros in the current window
        int left = 0;         // Left pointer for the sliding window

        // Iterate through the array using the right pointer
        for(int right = 0; right < arr.size(); right++) {
            // If the current element is zero, increment the zero count
            if(arr[right] == 0) {
                zeroCount++;
            }

            // If the count of zeros exceeds k, adjust the left pointer
            while(zeroCount > k) {
                // If the leftmost element is zero, decrement the zero count
                if(arr[left] == 0) {
                    zeroCount--;
                }
                // Move the left pointer to the right
                left++;
            }

            // Update the maximum length of the subarray found
            // right - left + 1 gives the size of the current window
            maxi = max(maxi, right - left + 1);
        }

        // Return the maximum length of the subarray with at most k zeros
        return maxi;
    }
};
